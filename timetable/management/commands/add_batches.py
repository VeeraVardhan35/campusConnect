from django.core.management.base import BaseCommand
from timetable.models import Batch
from django.db import transaction

class Command(BaseCommand):
    help = 'Populate Batch table with all known batches including sections'

    def handle(self, *args, **options):
        # Define batch data with years, branches, and sections
        batch_data = [
            # Computer Science (CSE) - 4 sections for each year
            {'batch_year': '2023', 'branch': 'cs', 'sections': ['A', 'B', 'C', 'D']},
            {'batch_year': '2024', 'branch': 'cs', 'sections': ['A', 'B', 'C', 'D']},
            {'batch_year': '2025', 'branch': 'cs', 'sections': ['A', 'B', 'C', 'D']},
            {'batch_year': '2026', 'branch': 'cs', 'sections': ['A', 'B', 'C', 'D']},
            
            # Electronics & Communication (ECE) - 4 sections for each year
            {'batch_year': '2023', 'branch': 'ec', 'sections': ['A', 'B', 'C', 'D']},
            {'batch_year': '2024', 'branch': 'ec', 'sections': ['A', 'B', 'C', 'D']},
            {'batch_year': '2025', 'branch': 'ec', 'sections': ['A', 'B', 'C', 'D']},
            {'batch_year': '2026', 'branch': 'ec', 'sections': ['A', 'B', 'C', 'D']},
            
            # Mechanical Engineering (ME) - 2 sections for each year
            {'batch_year': '2023', 'branch': 'me', 'sections': ['A', 'B']},
            {'batch_year': '2024', 'branch': 'me', 'sections': ['A', 'B']},
            {'batch_year': '2025', 'branch': 'me', 'sections': ['A', 'B']},
            {'batch_year': '2026', 'branch': 'me', 'sections': ['A', 'B']},
            
            # Smart Manufacturing (SM) - 2 sections for each year
            {'batch_year': '2023', 'branch': 'sm', 'sections': ['A', 'B']},
            {'batch_year': '2024', 'branch': 'sm', 'sections': ['A', 'B']},
            {'batch_year': '2025', 'branch': 'sm', 'sections': ['A', 'B']},
            {'batch_year': '2026', 'branch': 'sm', 'sections': ['A', 'B']},
        ]

        created_count = 0
        updated_count = 0
        skipped_count = 0

        self.stdout.write("Populating Batch table with all known batches...")
        self.stdout.write("=" * 60)

        # Use transaction for better performance
        with transaction.atomic():
            for batch_info in batch_data:
                batch_year = batch_info['batch_year']
                branch = batch_info['branch']
                sections = batch_info['sections']

                self.stdout.write(f"\nBatch {batch_year} - {branch.upper()}:")
                self.stdout.write("-" * 40)

                for section in sections:
                    # The name will be auto-generated by the save method
                    name = ""  # Leave empty to let save() method generate it

                    try:
                        # Try to get existing batch or create new one
                        batch, created = Batch.objects.update_or_create(
                            batch_year=batch_year,
                            branch=branch,
                            section=section,
                            defaults={
                                'batch_year': batch_year,
                                'branch': branch,
                                'section': section,
                                'name': name  # This will be auto-generated in save()
                            }
                        )

                        if created:
                            created_count += 1
                            self.stdout.write(
                                self.style.SUCCESS(f"  ✓ Created: {batch}")
                            )
                        else:
                            updated_count += 1
                            self.stdout.write(
                                self.style.WARNING(f"  ↻ Updated: {batch}")
                            )

                    except Exception as e:
                        skipped_count += 1
                        self.stdout.write(
                            self.style.ERROR(f"  ✗ Failed: {branch.upper()} {batch_year} Section {section} - Error: {e}")
                        )

        # Generate summary statistics
        self.stdout.write("\n" + "=" * 60)
        self.stdout.write("BATCH POPULATION SUMMARY:")
        self.stdout.write("=" * 60)

        # Breakdown by branch
        self.stdout.write("\nBreakdown by Branch:")
        branches = ['cs', 'ec', 'me', 'sm']
        for branch in branches:
            branch_batches = Batch.objects.filter(branch=branch)
            years = set(branch_batches.values_list('batch_year', flat=True))
            self.stdout.write(f"  {branch.upper()}: {branch_batches.count()} batches across {len(years)} years")

        # Breakdown by year
        self.stdout.write(f"\nBreakdown by Year:")
        years = set(Batch.objects.values_list('batch_year', flat=True))
        for year in sorted(years):
            year_batches = Batch.objects.filter(batch_year=year)
            self.stdout.write(f"  {year}: {year_batches.count()} batches")

        # Overall statistics
        self.stdout.write(f"\nOverall Statistics:")
        self.stdout.write(f"  Created: {created_count}")
        self.stdout.write(f"  Updated: {updated_count}")
        self.stdout.write(f"  Skipped: {skipped_count}")
        self.stdout.write(f"  Total Batches: {Batch.objects.count()}")

        # Show sample batches
        self.stdout.write(f"\nSample Batches:")
        self.stdout.write("-" * 40)
        sample_batches = Batch.objects.all().order_by('batch_year', 'branch', 'section')[:10]
        for batch in sample_batches:
            self.stdout.write(f"  {batch}")

        self.stdout.write(
            self.style.SUCCESS(f"\n✅ Batch population completed successfully!")
        )